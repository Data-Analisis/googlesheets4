---
output: github_document
---

```{r setup, include = FALSE}
can_decrypt <- gargle:::secret_can_decrypt("googlesheets4")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = can_decrypt,
  eval = can_decrypt
)
options(tibble.print_min = 5L, tibble.print_max = 5L)
```

```{r eval = !can_decrypt, echo = FALSE, comment = NA}
message("No token available. Code chunks will not be evaluated.")
```

```{r index-auth, include = FALSE}
googlesheets4:::sheets_auth_docs()
```

# googlesheets4

## Overview

googlesheets4 provides an R interface to [Google Sheets](https://spreadsheets.google.com/) via the [Sheets API v4](https://developers.google.com/sheets/api/). It is a reboot of an earlier package called [googlesheets](https://cran.r-project.org/package=googlesheets).

*Why **4**? Why googlesheets**4**? Did I miss googlesheets1 through 3? No. The idea is to name the package after the corresponding version of the Sheets API. In hindsight, the original googlesheets should have been googlesheets**3**.*

## Installation

You can install the released version of googlesheets4 from [CRAN](https://CRAN.R-project.org) with:

```{r, eval = FALSE}
install.packages("googlesheets4")
```

And the development version from [GitHub](https://github.com/) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("tidyverse/googlesheets4")
```

## Auth

googlesheets4 will, by default, help you interact with Sheets as an authenticated Google user. The package facilitates this process upon first need. If you don't need to access private Sheets, use `sheets_deauth()` to indicate there is no need for a token. See the article [googlesheets4 auth](https://googlesheets4.tidyverse.org/articles/articles/auth.html) for more.

For this overview, we've logged into Google as a specific user in a hidden chunk.

## Attach googlesheets4

```{r}
library(googlesheets4)
```

## `read_sheet()`, a.k.a. `sheets_read()`

`read_sheet()` is the main "read" function and should evoke `readr::read_csv()` and `readxl::read_excel()`. It's an alias for `sheets_read()`, because most functions in googlesheets4 actually start with `sheets_`. googlesheets4 is pipe-friendly (and reexports `%>%`), but works just fine without the pipe.

`read_sheet()` is designed to "just work", for most purposes, most of the time. It can read straight from a Sheets browser URL:

```{r}
sheets_read("https://docs.google.com/spreadsheets/d/1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY/edit#gid=780868077")
```

However, these URLs are not pleasant to work with. More often, you will want to identify a Sheet by its ID:

```{r}
sheets_read("1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY")
```

or by its name, which requires an assist from the googledrive package ([googledrive.tidyverse.org](https://googledrive.tidyverse.org)):

<!-- remove the 'message = i' later -->

```{r message=4}
library(googledrive)

drive_get("gapminder") %>% 
  sheets_read()
```

Note that the name-based approach above will only work if **you** have access to a Sheet named "gapminder". Sheet names cannot be used as absolute identifiers; only a Sheet ID can play that role.

For more Sheet identification concepts and strategies, see the article [Find and Identify Sheets](https://googlesheets4.tidyverse.org/articles/articles/find-identify-sheets.html).

## Example Sheets and `sheets_browse()`

We've made a few Sheets available to "anyone with a link", for use in examples and docs. Two helper functions make it easy to get your hands on these file IDs.

  * `sheets_examples()` lists all the example Sheets and it can also filter by
    matching names to a regular expression.
  * `sheets_example()` requires a regular expression and returns exactly 1 Sheet
    ID (or throws an error).
    
```{r}
sheets_example("chicken-sheet") %>% 
  sheets_read()
```

If you'd like to see a Sheet in the browser, including our example Sheets, use `sheets_browse()`:

```{r eval = FALSE}
sheets_example("deaths") %>%
  sheets_browse()
```

## Sheet metadata

`sheets_get()` exposes Sheet metadata, such as details on worksheets and named ranges.

```{r}
ss <- sheets_example("deaths")

sheets_get(ss)

sheets_sheet_properties(ss)

sheets_sheet_names(ss)
```

`sheets_sheet_properties()` and `sheets_sheet_names()` are two members of a family of functions for dealing with the (work)sheets within a (spread)Sheet.

The metadata exposed by `sheets_get()` is also revealed whenever you print an object that is known to be a `sheets_id` (an S3 class we use to make Sheet IDs).

## Identify and access your own Sheet
## Specify the range and column types

Here we read from the "mini-gap" and "deaths" example Sheets to show some of the different ways to specify (work)sheet and cell ranges. Note also that `col_types` gives control of column types, similar to how `col_types` works in readr and readxl.

```{r}
read_sheet(sheets_example("mini-gap"), sheet = 2)

read_sheet(sheets_example("mini-gap"), sheet = "Oceania", n_max = 3)

read_sheet(sheets_example("deaths"), skip = 4, n_max = 10)

read_sheet(
  sheets_example("deaths"), range = "other!A5:F15", col_types = "?ci??D"
)
```

If you looked at the "deaths" spreadsheet in the browser (it's [here](https://docs.google.com/spreadsheets/d/1tuYKzSbLukDLe5ymf_ZKdQA8SfOyeMM7rmf6D6NJpxg/edit#gid=1210215306)), you know that it has some of the typical features of real world spreadsheets: the main data rectangle has prose intended for human-consumption before and after it. That's why we have to specify the range when we read from it.

We've designated the data rectangles as [named ranges](https://support.google.com/docs/answer/63175?co=GENIE.Platform%3DDesktop&hl=en), which provides a very slick way to read them -- definitely less brittle and mysterious than approaches like `range = "other!A5:F15"` or `skip = 4, n_max = 10`. A named range can be passed via the `range =` argument:

```{r}
sheets_example("deaths") %>% 
  read_sheet(range = "arts_data")
```

The named ranges, if any exist, are part of the information returned by `sheets_get()`.

## Detailed cell data

`sheets_cells()` returns a data frame with one row per cell and it gives access to raw cell data sent by the Sheets API.

```{r}
(df <- sheets_cells(sheets_example("deaths"), range = "E5:E7"))
df$cell[[3]]
```

Specify `cell_data = "full", discard_empty = FALSE` to get even more data if you, for example, need access to cell formulas or formatting.

`spread_sheet()` `r emo::ji("wink")` converts data in the "one row per cell" form into the data frame you get from `read_sheet()`, which involves reshaping and column typing.

```{r}
df %>% spread_sheet(col_types = "D")
## is same as ...
read_sheet(sheets_example("deaths"), range = "E5:E7", col_types ="D")
```

## Writing Sheets

*The writing functions are the most recent additions and are likely to some refinements re: user interface and which function does what.*

`sheets_write()` writes a data frame into a Sheet. The only required argument is the data.

```{r}
df <- data.frame(x = 1:3, y = letters[1:3])

ss <- sheets_write(df)
ss
```

You'll notice the new (spread)Sheet has a randomly generated name. If that is a problem, use `sheets_create()` instead, which affords more control over various aspects of the new Sheet.

Let's start over: we delete that Sheet and call `sheets_create()`, so we can specify the new Sheet's name.

```{r}
drive_rm(ss)

ss <- sheets_create("fluffy-bunny", sheets = df)
```

`sheets_write()` can write to new or existing (work)sheets in this Sheet. Let's write the `chickwts` data to a new sheet in `ss`.

```{r}
sheets_write(chickwts, ss)
```

We can also use `sheets_write()` to replace the data in an existing sheet.

```{r}
sheets_write(data.frame(x = 4:10, letters[4:10]), ss, sheet = "df")
```

`sheets_append()` adds one or more rows to an existing sheet.

```{r}
sheets_append(data.frame(x = 11, letters[11]), ss, sheet = "df")
```

There is also a family of `sheets_sheet_*()` functions that do pure (work)sheet operations, such as add and delete.

We take one last look at the sheets we created in `ss`, then clean up.

```{r}
sheets_sheet_properties(ss)

drive_rm(ss)
```

*Exists but is not demonstrated here yet `sheets_edit()`, for writing into an arbitrary range.*

See also the article [Write Sheets](https://googlesheets4.tidyverse.org/articles/articles/write-sheets.html).

## Contributing

If you'd like to contribute to the development of googlesheets4, please read [these guidelines](https://googlesheets4.tidyverse.org/CONTRIBUTING.html).

Please note that the googlesheets4 project is released with a [Contributor Code of Conduct](https://googlesheets4.tidyverse.org/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.

## Privacy

[Privacy policy](https://www.tidyverse.org/google_privacy_policy)

## Context

googlesheets4 draws on and complements / emulates other packages in the tidyverse:

  * [googlesheets](https://cran.r-project.org/package=googlesheets) is the package that googlesheets4 is replacing. Main improvements in googlesheets4: (1) wraps the current, most modern Sheets API; (2) leans on googledrive for all "whole file" operations; and (3) uses shared infrastructure for auth and more, from the gargle package. The v3 API wrapped by googlesheets goes offline in March 2020, at which point the package must be retired.
  * [googledrive](https://googledrive.tidyverse.org) provides a fully-featured interface to the Google Drive API. Any "whole file" operations can be accomplished with googledrive: upload or download or update a spreadsheet, copy, rename, move, change permission, delete, etc. googledrive supports Team Drives.
  * [readxl](https://readxl.tidyverse.org) is the tidyverse package for reading Excel files (xls or xlsx) into an R data frame. googlesheets4 takes cues from parts of the readxl interface, especially around specifying which cells to read.
  * [readr](https://readr.tidyverse.org) is the tidyverse package for reading delimited files (e.g., csv or tsv) into an R data frame. googlesheets4 takes cues from readr with respect to column type specification.
